<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="Daniel Parrales">
    <meta name="description" content="Ejercicios con Kubernetes">
    <meta name="keywords" content="blog,developer,personal,">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ejercicios con Kubernetes"/>
<meta name="twitter:description" content="Ejercicios con Kubernetes"/>

    <meta property="og:title" content="Ejercicios con Kubernetes" />
<meta property="og:description" content="Ejercicios con Kubernetes" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sysadblog.onrender.com/posts/ejercicios_kubernetes/" />
<meta property="article:published_time" content="2022-01-27T18:59:42+01:00" />
<meta property="article:modified_time" content="2022-01-27T18:59:42+01:00" />


    <title>
  Ejercicios con Kubernetes · Sysadblog
</title>

    
      <link rel="canonical" href="https://sysadblog.onrender.com/posts/ejercicios_kubernetes/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.8e2b2510f60e1715eae08d113a808dcdaf17f6f711edb9e969be38d0074d240d.css" integrity="sha256-jislEPYOFxXq4I0ROoCNza8X9vcR7bnpab440AdNJA0=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.aa883b9ce35a8ff4a2a5008619005175e842bb18a8a9f9cc2bbcf44dab2d91fa.css" integrity="sha256-qog7nONaj/SipQCGGQBRdehCuxioqfnMK7z0Tastkfo=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    

    <meta name="generator" content="Hugo 0.80.0" />
  </head>

  
  
    
  
  <body class="preload-transitions colorscheme-auto"
        onload=""
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Sysadblog
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/aboutme">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories">Categories</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://sysadblog.onrender.com/posts/ejercicios_kubernetes/">
              Ejercicios con Kubernetes
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2022-01-27T18:59:42&#43;01:00'>
                January 27, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              21-minute read
            </span>
          </div>
          <div class="authors">
    <i class="fa fa-user" aria-hidden="true"></i>
      <a href="/authors/daniel-parrales/">Daniel Parrales</a></div>
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/cloud-computing/">Cloud Computing</a></div>

          
        </div>
      </header>

      <div>
        
        <h1 id="ejercicios-con-kubernetes">
  Ejercicios con Kubernetes
  <a class="heading-link" href="#ejercicios-con-kubernetes">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<p>Vamos a realizar los ejercicios que se encuentran en <a href="https://github.com/iesgn/curso_kubernetes_cep">este</a> curso de Kubernetes.</p>
<h2 id="contenedores-en-kubernetes-pods">
  Contenedores en Kubernetes: Pods
  <a class="heading-link" href="#contenedores-en-kubernetes-pods">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="actividad-trabajando-con-pods">
  Actividad: Trabajando con Pods
  <a class="heading-link" href="#actividad-trabajando-con-pods">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Vamos a crear nuestro primer Pod, y para ellos vamos a desplegar una imagen que nos ofrece un servidor web con una página estática. Para ello realiza los siguientes pasos:</p>
<ol>
<li>Crea un fichero yaml con la descripción del recurso Pod, teniendo en cuenta los siguientes aspectos:
<ul>
<li>Indica nombres distintos para el Pod y para el contenedor.</li>
<li>La imagen que debes desplegar es <code>iesgn/test_web:latest</code>.</li>
<li>Indica una etiqueta en la descripción del Pod.</li>
</ul>
</li>
<li>Crea el Pod.</li>
<li>Comprueba que el Pod se ha creado y está corriendo.</li>
<li>Obtén información detallada del Pod creado.</li>
<li>Accede de forma interactiva al Pod y comprueba los ficheros que están en el DocumentRoot (<code>usr/local/apache2/htdocs/</code>).</li>
<li>Crea una redirección con <code>kubectl port-forward</code> utilizando el puerto de localhost 8888 y sabiendo que el Pod ofrece el servicio en el puerto 80. Accede a la aplicación desde un navegador.</li>
<li>Muestra los logs del Pod y comprueba que se visualizan los logs de los accesos que hemos realizado en el punto anterior.</li>
<li>Elimina el Pod, y comprueba que ha sido eliminado.</li>
</ol>
<hr>
<p>Para creamos un fichero <code>.yaml</code> con la siguiente información:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">apiVersion: v1
kind: Pod
metadata:
 name: pod-test-web
 labels:
   service: web
spec:
 containers:
   - image: iesgn/test_web:latest
     name: contenedor-test-web
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_1.png" alt="img_1.png"></p>
<p>A continuación creamos el pod:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f test_web.yaml
</code></pre></div><p>Podemos ver que se ha creado con el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get pods
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_2.png" alt="img_2.png"></p>
<p>Si lo queremos ver más detallado, podemos usar el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get pod -o wide
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_3.png" alt="img_3.png"></p>
<p>Como vemos, el pod esta encendido y funcionando de forma correcta. No es lo habitual, pero podemos acceder al pod (en este caso tiene un solo contenedor) con el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl exec -it pod-test-web -- /bin/bash
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_4.png" alt="img_4.png"></p>
<p>Otra cosa que podemos hacer con el pod es crear una redirección de los puertos, de forma que al acceder a uno de los puertos en el anfitrión podremos ver la página web servida por el pod que hemos creado:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward pod-test-web 8888:80

Forwarding from 127.0.0.1:8888 -&gt; 80
Forwarding from [::1]:8888 -&gt; 80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_5.png" alt="img_5.png"></p>
<p>También podemos ver los logs de los pods, por si hubiera algún problema. Para ello usamos el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl logs pod-test-web
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_6.png" alt="img_6.png"></p>
<p>Por último, si ya no nos hiciera falta el pod, lo eliminaríamos con el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl delete pod pod-test-web
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_7.png" alt="img_7.png"></p>
<p>Con esto último damos por finalizado el ejercicio de introducción a los pods.</p>
<h2 id="tolerancia-y-escalabilidad-replicasets">
  Tolerancia y escalabilidad: ReplicaSets
  <a class="heading-link" href="#tolerancia-y-escalabilidad-replicasets">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="actividad-trabajando-con-replicaset">
  Actividad: Trabajando con ReplicaSet
  <a class="heading-link" href="#actividad-trabajando-con-replicaset">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Como indicamos en el contenido de este módulo, no se va a trabajar directamente con los Pods (realmente tampoco vamos a trabajar directamente con los ReplicaSet, en el siguiente módulo explicaremos los Deployments que serán el recurso con el que trabajaremos). En este ejercicio vamos a crear un ReplicaSet que va a controlar un conjunto de Pods. Para ello, realiza los siguientes pasos:</p>
<ol>
<li>Crea un fichero yaml con la descripción del recurso ReplicaSet, teniendo en cuenta los siguientes aspectos:
<ul>
<li>Indica nombres distintos para el ReplicaSet y para el contenedor de los Pods que va a controlar.</li>
<li>El ReplicaSet va a crear 3 réplicas.</li>
<li>La imagen que debes desplegar es <code>iesgn/test_web:latest</code>.</li>
<li>Indica de manera adecuada una etiqueta en la especificación del Pod que vas a definir que coincida con el selector del ReplicaSet.</li>
</ul>
</li>
<li>Crea el ReplicaSet.</li>
<li>Comprueba que se ha creado el ReplicaSet y los 3 Pods.</li>
<li>Obtén información detallada del ReplicaSet creado.</li>
<li>Vamos a probar la tolerancia a fallos: Elimina uno de los 3 Pods, y comprueba que inmediatamente se ha vuelto a crear un nuevo Pod.</li>
<li>Vamos a comprobar la escalabilidad: escala el ReplicaSet para tener 6 Pods de la aplicación.</li>
<li>Elimina el ReplicaSet y comprueba que se han borrado todos los Pods.</li>
</ol>
<hr>
<p>Así pues, en primer lugar creamos un fichero <code>.yaml</code> en el cual definiremos el ReplicaSet y los contenedores que manejará:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replica-test-web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-prueba
  template:
    metadata:
      labels:
        app: web-prueba
    spec:
      containers:
        - image: iesgn/test_web:latest
          name: contenedor-test-web
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_8.png" alt="img_8.png"></p>
<p>Para crear el ReplicaSet usamos la siguiente orden:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f test-web.yaml
</code></pre></div><p>Podemos ver que se ha creado el ReplicaSet y los pods que hemos definido:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get rs,pods
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_9.png" alt="img_9.png"></p>
<p>Al igual que hicimos con los pods en el ejercicio anterior, podemos obtener información más detallada del ReplicaSet. Para ello ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl describe rs replica-test-web
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_10.png" alt="img_10.png"></p>
<p>Una de las ventajas que ofrecen los ReplicaSets es la tolerancia a fallos, de forma que si eliminamos uno de los pods de forma accidental o por algún error, se volverá a crear. Veámoslo:</p>
<p><img src="/images/ejercicios_kubernetes/img_11.png" alt="img_11.png"></p>
<p>Como vemos, al eliminar un pod, se ha creado otro inmediatamente, de forma que Kubernetes va a tratar de que siempre tengamos activos el número de pods que le hemos indicado.</p>
<p>Otra de las ventajas que ofrece Kubernetes es la escalabilidad, de forma que si en algún momento necesitamos más o menos pods, simplemente tendremos que indicárselo y Kubernetes se encargará del resto. Para probarlo, le indicaremos a Kubernetes que a partir de ahora queremos tener 6 pods en lugar de los 3 que le indicamos en fichero de definición del ReplicaSet:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl scale rs replica-test-web --replicas=6
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_12.png" alt="img_12.png"></p>
<p>Como vemos, ha creado otros 3 pods. Ya solo nos queda eliminar el ReplicaSet, para lo cual ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl delete rs replica-test-web 
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_13.png" alt="img_13.png"></p>
<p>Con la eliminación del ReplicaSet, damos por finalizado este ejercicio.</p>
<h2 id="despliegues">
  Despliegues
  <a class="heading-link" href="#despliegues">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="trabajando-con-deployments">
  Trabajando con Deployments
  <a class="heading-link" href="#trabajando-con-deployments">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>En esta actividad vamos a crear un Deployment de una aplicación web. Sigamos los siguientes pasos:</p>
<ol>
<li>Crea un fichero yaml con la descripción del recurso Deployment, teniendo en cuenta los siguientes aspectos:
<ul>
<li>Indica nombres distintos para el Deployment y para el contenedor de los Pods que va a controlar.</li>
<li>El Deployment va a crear 2 réplicas.</li>
<li>La imagen que debes desplegar es <code>iesgn/test_web:latest</code>.</li>
<li>Indica de manera adecuada una etiqueta en la especificación del Pod que vas a definir que coincida con el selector del Deployment.</li>
</ul>
</li>
<li>Crea el Deployment.</li>
<li>Comprueba los recursos que se han creado: Deployment, ReplicaSet y Pods.</li>
<li>Obtén información detallada del Deployment creado.</li>
<li>Crea un una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</li>
<li>Accede a los logs del despliegue para comprobar el acceso que has hecho en el punto anterior.</li>
<li>Elimina el Deployment y comprueba que se han borrado todos los recursos creados.</li>
</ol>
<hr>
<p>Vamos a empezar creando el fichero yaml:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano deployment-test-web.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-testweb
  labels:
    app: web
spec:
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
  replicas: 2
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - image: iesgn/test_web:latest
        name: contendor-testweb
        ports:
        - name: http
          containerPort: 80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_14.png" alt="img_14.png"></p>
<p>Lanzamos el deployment:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f deployment-test-web.yaml
</code></pre></div><p>Podemos ver los recursos que se han creado:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get all
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_15.png" alt="img_15.png"></p>
<p>Si queremos ver información más detallada del deployment, ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl describe deployment.apps/deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_16.png" alt="img_16.png"></p>
<p>Si queremos comprobar que la aplicación se está sirviendo, podemos crear momentáneamente una redirección para acceder a través del navegador:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/deployment-testweb 8080:80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_17.png" alt="img_17.png"></p>
<p>También podemos acceder a los logs del deployment para ver el acceso que hemos hecho a través del navegador web:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl logs deployment.apps/deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_18.png" alt="img_18.png"></p>
<p>Por último, podemos eliminar el deployment con la siguiente orden:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl delete deployments.apps deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_19.png" alt="img_19.png"></p>
<p>Con esto, damos por finalizado este ejercicio.</p>
<h3 id="actualización-y-desactualización-de-nuestra-aplicación">
  Actualización y desactualización de nuestra aplicación
  <a class="heading-link" href="#actualizaci%c3%b3n-y-desactualizaci%c3%b3n-de-nuestra-aplicaci%c3%b3n">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>El equipo de desarrollo ha creado una primera versión preliminar de una aplicación web y ha creado una imagen de contenedor con el siguiente nombre: <code>iesgn/test_web:version1</code>.</p>
<p>Vamos a desplegar esta primera versión de la aplicación, para ello:</p>
<ol>
<li>Crea un fichero yaml (puedes usar el de la actividad anterior) para desplegar la imagen: <code>iesgn/test_web:version1</code>.</li>
<li>Crea el Deployment, recuerda la opción que nos permite registrar los comandos que vamos a ejecutar a continuación para ir actualizando el despliegue.</li>
<li>Crea una redirección utilizando el <code>port-forward</code> para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</li>
</ol>
<hr>
<p>En primer lugar, crearemos el fichero yaml correspondiente a este despliegue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano deployment-test-web2.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-testweb
  labels:
    app: web
spec:
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - image: iesgn/test_web:version1
        name: contendor-testweb
        ports:
        - name: http
          containerPort: 80
</code></pre></div><p>Ahora lanzamos el despliegue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f deployment-test-web2.yaml
</code></pre></div><p>Y anotamos el despliegue para tener un registro:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl annotate deployment/deployment-testweb kubernetes.io/change-cause=&#34;Lanzamos la primera versión de la aplicación&#34;
</code></pre></div><p>Podemos acceder a través del navegador usando el <code>port-forwarding</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/deployment-testweb 8080:80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_20.png" alt="img_20.png"></p>
<hr>
<p>Nuestro equipo de desarrollo ha seguido trabajando y ya tiene lista la versión 2 de nuestra aplicación, han creado una imagen que se llama: <code>iesgn/test_web:version2</code>. Vamos a actualizar nuestro despliegue con la nueva versión, para ello:</p>
<ol>
<li>Realiza la actualización del despliegue utilizando la nueva imagen.</li>
<li>Comprueba los recursos que se han creado: Deployment, ReplicaSet y Pods.</li>
<li>Visualiza el historial de actualizaciones.</li>
<li>Crea una redirección utilizando el <code>port-forward</code> para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</li>
</ol>
<hr>
<p>Para ello ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl set image deployment.apps/deployment-testweb contendor-testweb=iesgn/test_web:version2
</code></pre></div><p>Y creamos la anotación:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl annotate deployment/deployment-testweb kubernetes.io/change-cause=&#34;Lanzamos la segunda versión de la aplicación&#34;
</code></pre></div><p>Podemos ver que se han creado los nuevos recursos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get all
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_21.png" alt="img_21.png"></p>
<p>Si vemos el historial de actualizaciones, nos saldrán los dos deployments que hemos hecho junto con las anotaciones:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl rollout history deployment deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_22.png" alt="img_22.png"></p>
<p>Ahora podemos acceder a la web usando el <code>port-forwarding</code> y ver si se han producido los cambios:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/deployment-testweb 8080:80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_23.png" alt="img_23.png"></p>
<hr>
<p>Finalmente después de un trabajo muy duro, el equipo de desarrollo ha creado la imagen iesgn/test_web:version3 con la última versión de nuestra aplicación y la vamos a poner en producción, para ello:</p>
<ol>
<li>Realiza la actualización del despliegue utilizando la nueva imagen.</li>
<li>Comprueba los recursos que se han creado: Deployment, ReplicaSet y Pods.</li>
<li>Visualiza el historial de actualizaciones.</li>
<li>Crea una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</li>
</ol>
<hr>
<p>Para ello ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl set image deployment.apps/deployment-testweb contendor-testweb=iesgn/test_web:version3
</code></pre></div><p>Y creamos la anotación:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl annotate deployment/deployment-testweb kubernetes.io/change-cause=&#34;Lanzamos la tercera versión de la aplicación&#34;
</code></pre></div><p>Podemos ver que se han creado los nuevos recursos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get all
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_24.png" alt="img_24.png"></p>
<p>Si vemos el historial de actualizaciones, nos saldrán los dos deployments que hemos hecho junto con las anotaciones:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl rollout history deployment deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_25.png" alt="img_25.png"></p>
<p>Ahora podemos acceder a la web usando el <code>port-forwarding</code> y ver si se han producido los cambios:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/deployment-testweb 8080:80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_26.png" alt="img_26.png"></p>
<hr>
<p>¡Vaya!, parece que esta versión tiene un fallo, y no se ve de forma adecuada la hoja de estilos, tenemos que volver a la versión anterior:</p>
<ol>
<li>Ejecuta la instrucción que nos permite hacer un rollback de nuestro despliegue.</li>
<li>Comprueba los recursos que se han creado: Deployment, ReplicaSet y Pods.</li>
<li>Visualiza el historial de actualizaciones.</li>
<li>Crea una redirección utilizando el <code>port-forward</code> para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</li>
</ol>
<hr>
<p>Para volver a la versión anterior ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl rollout undo deployment.apps/deployment-testweb
</code></pre></div><p>Y lo anotamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl annotate deployment/deployment-testweb kubernetes.io/change-cause=&#34;Volvemos a la segunda versión de la aplicación&#34;
</code></pre></div><p>Vemos los recursos que se han creado:</p>
<p><img src="/images/ejercicios_kubernetes/img_27.png" alt="img_27.png"></p>
<p>Si visualizamos el historial de actualizaciones, veremos que los números han cambiado, y hemos vuelto a la versión dos (ha desaparecido el número dos y se ha cambiado por el cuatro):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl rollout history deployment deployment-testweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_28.png" alt="img_28.png"></p>
<p>Si ahora vemos la página web a través del <code>port-forward</code>, veremos que, efectivamente, hemos vuelto a la versión dos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/deployment-testweb 8080:80
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_29.png" alt="img_29.png"></p>
<p>Con esto, terminamos este ejercicio.</p>
<h3 id="despliegue-de-la-aplicación-guestbook">
  Despliegue de la aplicación GuestBook
  <a class="heading-link" href="#despliegue-de-la-aplicaci%c3%b3n-guestbook">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>En esta tarea vamos a desplegar una aplicación web que requiere de dos servicios para su ejecución. La aplicación se llama GuestBook y necesita los siguientes servicios:</p>
<ul>
<li>La aplicación Guestbook es una aplicación web desarrollada en python que es servida en el puerto 5000/tcp. Utilizaremos la imagen <code>iesgn/guestbook</code>.</li>
<li>Esta aplicación guarda la información en una base de datos no relacional redis, que utiliza el puerto 6379/tcp para recibir las conexiones. Usaremos la imagen <code>redis</code>.</li>
</ul>
<p>Por lo tanto si tenemos dos servicios distintos, tendremos dos ficheros yaml para crear dos recursos Deployment, uno para cada servicio. Con esta manera de trabajar podemos obtener las siguientes características:</p>
<ul>
<li>Cada conjunto de Pods creado en cada despliegue ejecutarán un solo proceso para ofrecer el servicio.</li>
<li>Cada conjunto de Pods se puede escalar de manera independiente. Esto es importante, si identificamos que al acceder a alguno de los servicios se crea un cuello de botella, podemos escalarlo para tener más Pods ejecutando el servicio.</li>
<li>Las actualizaciones de los distintos servicios no interfieren en el resto.</li>
<li>Lo estudiaremos en un módulo posterior, pero podremos gestionar el almacenamiento de cada servicio de forma independiente.</li>
</ul>
<p>Por lo tanto para desplegar la aplicaciones tendremos dos ficheros.yaml:</p>
<ul>
<li><a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/files/guestbook/guestbook-deployment.yaml">guestbook-deployment.yaml</a></li>
<li><a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/files/guestbook/redis-deployment.yaml">redis-deployment.yaml</a></li>
</ul>
<p>Para realizar el despliegue realiza los siguientes pasos:</p>
<ul>
<li>Usando los ficheros anteriores crea los dos Deployments.</li>
<li>Comprueba que los recursos que se han creado: Deployment, ReplicaSet y Pods.</li>
<li>Crea una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 5000, y accede a la aplicación con un navegador web.</li>
</ul>
<hr>
<p>Así pues, creamos los dos ficheros para los deployments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano guestbook-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: guestbook
  labels:
    app: guestbook
    tier: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: guestbook
      tier: frontend
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: contenedor-guestbook
        image: iesgn/guestbook
        ports:
          - name: http-server
            containerPort: 5000
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano redis-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  labels:
    app: redis
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      tier: backend
  template:
    metadata:
      labels:
        app: redis
        tier: backend
    spec:
      containers:
        - name: contenedor-redis
          image: redis
          ports:
            - name: redis-server
              containerPort: 6379
</code></pre></div><p>Una vez hemos terminado con los ficheros, creamos los dos deployments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f guestbook-deployment.yaml

kubectl apply -f redis-deployment.yaml
</code></pre></div><p>Podemos ver lo servicios que se han creado:</p>
<p><img src="/images/ejercicios_kubernetes/img_30.png" alt="img_30.png"></p>
<p>Si hacemos un <code>port-forward</code> podemos acceder a la página de guestbook, pero nos indica el siguiente mensaje:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl port-forward deployment.apps/guestbook 5000:5000
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_31.png" alt="img_31.png"></p>
<p>Este mensaje nos sale porque los contenedores de guestbook no pueden acceder a la base de datos redis. En el siguiente apartado veremos como conectar los contenedores en kubernetes.</p>
<h2 id="acceso-a-las-aplicaciones-servicios">
  Acceso a las aplicaciones: Servicios
  <a class="heading-link" href="#acceso-a-las-aplicaciones-servicios">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="despliegue-y-acceso-de-la-aplicación-guestbook">
  Despliegue y acceso de la aplicación GuestBook
  <a class="heading-link" href="#despliegue-y-acceso-de-la-aplicaci%c3%b3n-guestbook">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Una vez que tenemos creado el despliegue de la aplicación, que realizamos en la actividad anterior, vamos a crear los Services correspondientes para acceder a ella:</p>
<ul>
<li>Service para acceder a la aplicación:</li>
</ul>
<p>El Servicio para acceder a la aplicación será del tipo &ldquo;NodePort&rdquo;, y será definido con el siguiente yaml:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano servicio_guestbook.yaml

apiVersion: v1
kind: Service
metadata:
  name: guestbook
  labels:
    app: guestbook
    tier: frontend
spec:
  type: NodePort
  ports:
  - port: 80 
    targetPort: http-server
  selector:
    app: guestbook
    tier: frontend
</code></pre></div><p>Una vez que hemos definido el servicio, lo lanzamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f servicio_guestbook.yaml
</code></pre></div><p>Podemos ver el puerto que nos ha asignado viendo la lista de recursos que se han creado:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get all
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_32.png" alt="img_32.png"></p>
<p>Como vemos, se ha asignado el puerto 32127 para poder acceder al servicio desde el exterior. Podemos usar el navegador para acceder al servicio si usamos ese puerto:</p>
<p><img src="/images/ejercicios_kubernetes/img_33.png" alt="img_33.png"></p>
<p>Nos sigue apareciendo el mensaje de &ldquo;Waiting for database connection&hellip;&rdquo;. Esto es así porque el servicio que hemos creado sirve para conectar el exterior con las máquinas del &ldquo;frontend&rdquo;, sin embargo, no hemos creado aún el servicio que permita al &ldquo;frontend&rdquo; y el &ldquo;backend&rdquo; conectarse.</p>
<ul>
<li>Service para que la aplicación se conecte a la base de datos:</li>
</ul>
<p>El servicio que conectará el &ldquo;frontend&rdquo; y el &ldquo;backend&rdquo; será de tipo ClusterIP, y estará definido en el siguiente yaml:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano servicio_redis.yaml

apiVersion: v1
kind: Service
metadata:
  name: redis
  labels:
    app: redis
    tier: backend
spec:
  type: ClusterIP
  ports:
  - port: 6379
    targetPort: redis-server
  selector:
    app: redis
    tier: backend
</code></pre></div><p>Una vez que hemos terminado con el fichero yaml, lanzamos el servicio:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f servicio_redis.yaml
</code></pre></div><p>Podemos ver que se ha creado el servicio:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get all
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_34.png" alt="img_34.png"></p>
<p>Ahora que hemos creado este servicio, la aplicación debería poder conectarse perfectamente con la base de datos, por lo que el mensaje anterior de &ldquo;Waiting for database connection&hellip;&rdquo; debería haber desaparecido:</p>
<p><img src="/images/ejercicios_kubernetes/img_35.png" alt="img_35.png"></p>
<p>A continuación, vamos a crear un recurso de tipo &ldquo;Ingress&rdquo;, que nos permita acceder a la aplicación usando un nombre en lugar de la ip (básicamente actuará de proxy). Sin embargo, como estamos usando &ldquo;minikube&rdquo;, debemos habilitar primero ese tipo de recursos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">minikube addons enable ingress
</code></pre></div><p>Una vez habilitado, podemos crear el fichero yaml en el cual definiremos el nuevo recurso:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano ingress_guestbook.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: guestbook
spec:
  rules:
  - host: www.dparrales.org
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: guestbook
            port:
              number: 80
</code></pre></div><p>Una vez finalizado con el fichero, creamos el nuevo recurso:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f ingress_guestbook.yaml
</code></pre></div><p>Podemos ver el recurso creado:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get ingress
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_36.png" alt="img_36.png"></p>
<p>Para que podemos acceder a la web usando el nombre que le hemos asignado, debemos modificar el fichero <code>/etc/hosts</code> y añadir la siguiente línea:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">192.168.39.80 www.dparrales.org
</code></pre></div><p>Ahora podemos acceder a la aplicación &ldquo;guestbook&rdquo; usando el nombre que le hemos asignado:</p>
<p><img src="/images/ejercicios_kubernetes/img_37.png" alt="img_37.png"></p>
<p>Con esto, damos por finalizado este ejercicio.</p>
<h2 id="despliegues-parametrizados">
  Despliegues parametrizados
  <a class="heading-link" href="#despliegues-parametrizados">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="configurando-nuestra-aplicación-temperaturas">
  Configurando nuestra aplicación &ldquo;Temperaturas&rdquo;
  <a class="heading-link" href="#configurando-nuestra-aplicaci%c3%b3n-temperaturas">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>En un ejemplo del módulo anterior: <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/temperaturas.md">Ejemplo completo: Desplegando y accediendo a la aplicación Temperaturas</a> habíamos desplegado una aplicación formada por dos microservicios que nos permitía visualizar las temperaturas de municipios.</p>
<p>Recordamos que el componente <code>frontend</code> hace peticiones al componente <code>backend</code> utilizando el nombre <code>temperaturas-backend</code>, que es el nombre que asignamos al Service ClusterIP para el acceso al <code>backend</code>.</p>
<p>Vamos a cambiar la configuración de la aplicación para indicar otro nombre.</p>
<p>Podemos configurar el nombre del servidor <code>backend</code> al que vamos acceder desde el <code>frontend</code> modificando la variable de entorno <em>TEMP_SERVER</em> a la hora de crear el despliegue del <code>frontend</code>.</p>
<p>Por defecto el valor de esa variable es:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">TEMP_SERVER temperaturas-backend:5000
</code></pre></div><p>Vamos a modificar esta variable en el despliegue del <code>frontend</code> y cambiaremos el nombre del Service del <code>backend</code> para que coincidan, para ello realiza los siguientes pasos:</p>
<ol>
<li>Crea un recurso <code>ConfigMap</code> con un dato que tenga como clave <strong>SERVIDOR_TEMPERATURAS</strong> y como contenido <strong>servidor-temperaturas:5000</strong>.</li>
<li>Modifica el fichero de despliegue del <code>frontend</code>: <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/files/temperaturas/frontend-deployment.yaml">frontend-deployment.yaml</a> para añadir la modificación de la variable <strong>TEMP_SERVER</strong> con el valor que hemos guardado en el <code>ConfigMap</code>.</li>
<li>Realiza el despliegue y crea el Service para acceder al <code>frontend</code>.</li>
<li>Despliega el microservicio <code>backend</code>.</li>
<li>Modifica el fichero <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/files/temperaturas/backend-srv.yaml">backend-srv.yaml</a> para cambiar el nombre del Service por <code>servidor-temperaturas</code> y crea el Service.</li>
<li>Accede a la aplicación usando el puerto asignado al Service NodePort del <code>frontend</code> o creando el recurso <code>Ingress</code>.</li>
</ol>
<hr>
<p>En primer lugar, vamos a crear el recurso &ldquo;ConfigMap&rdquo; con los valores indicados:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl create cm temperaturas --from-literal=SERVIDOR_TEMPERATURAS=servidor-temperaturas:5000
</code></pre></div><p>Podemos ver la definición del recurso con el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl describe cm temperaturas
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_38.png" alt="img_38.png"></p>
<p>A continuación crearemos los cuatro ficheros yaml que usaremos para desplegar la aplicación:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano frontend-deployment.yaml


apiVersion: apps/v1
kind: Deployment
metadata:
  name: temperaturas-frontend
  labels:
    app: temperaturas
    tier: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: temperaturas
      tier: frontend
  template:
    metadata:
      labels:
        app: temperaturas
        tier: frontend
    spec:
      containers:
      - name: contenedor-temperaturas
        image: iesgn/temperaturas_frontend
        ports:
          - name: http-server
            containerPort: 3000
        env:
          - name: TEMP_SERVER
            valueFrom:
              configMapKeyRef:
                name: temperaturas
                key: SERVIDOR_TEMPERATURAS
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_39.png" alt="img_39.png"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano frontend-srv.yaml

apiVersion: v1
kind: Service
metadata:
  name: temperaturas-frontend
  labels:
    app: temperaturas
    tier: frontend
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: http-server
  selector:
    app: temperaturas
    tier: frontend
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano backend-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: temperaturas-backend
  labels:
    app: temperaturas
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: temperaturas
      tier: backend
  template:
    metadata:
      labels:
        app: temperaturas
        tier: backend
    spec:
      containers:
        - name: contendor-servidor-temperaturas
          image: iesgn/temperaturas_backend
          ports:
            - name: api-server
              containerPort: 5000
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano backend-srv.yaml

apiVersion: v1
kind: Service
metadata:
  name: servidor-temperaturas
  labels:
    app: temperaturas
    tier: backend
spec:
  type: ClusterIP
  ports:
  - port: 5000
    targetPort: api-server
  selector:
    app: temperaturas
    tier: backend
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_40.png" alt="img_40.png"></p>
<p>Ahora podemos crear todos los recursos que hemos definido en este directorio con el siguiente comando:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f .
</code></pre></div><p>Podemos ver todos los recursos que se han creado:</p>
<p><img src="/images/ejercicios_kubernetes/img_41.png" alt="img_41.png"></p>
<p>Ahora intentemos acceder a la aplicación a través del navegador, usando el servicio <code>NodePort</code> que hemos creado:</p>
<p><img src="/images/ejercicios_kubernetes/img_42.png" alt="img_42.png"></p>
<p>Como vemos, no nos indica ningún error, por lo que podemos dar por concluido este ejercicio.</p>
<h2 id="almacenamiento-en-kubernetes">
  Almacenamiento en Kubernetes
  <a class="heading-link" href="#almacenamiento-en-kubernetes">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="desplegando-un-servidor-web-persistente">
  Desplegando un servidor web persistente
  <a class="heading-link" href="#desplegando-un-servidor-web-persistente">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Siguiendo la guía explicada en el <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo8/ejemplo2.md">Ejemplo 2: Gestión dinámica de volúmenes</a>, vamos a crear un servidor web que permita la ejecución de scripts PHP con almacenamiento persistente.</p>
<p>Para realizar esta actividad vamos a usar asignación dinámica de volúmenes y puedes usar, como modelos, los ficheros del ejemplo 2.</p>
<p>Realiza los siguientes pasos:</p>
<ol>
<li>Crea un fichero yaml para definir un recurso PersistentVolumenClaim que se llame <code>pvc-webserver</code> y para solicitar un volumen de 2Gb.</li>
<li>Crea el recurso y comprueba que se ha asociado un volumen de forma dinámica a la solicitud.</li>
<li>Crea un fichero yaml para desplegar un servidor web desde la imagen <code>php:7.4-apache</code>, asocia el volumen al Pod que se va a crear e indica el punto de montaje en el DocumentRoot del servidor: <code>/var/www/html</code>.</li>
<li>Despliega el servidor y crea un fichero <code>info.php</code> en <code>/var/www/html</code>, con el siguiente contenido: <code>&lt;?php phpinfo(); ?&gt;</code>.</li>
<li>Define y crea un Service NodePort, accede desde un navegador al fichero <code>info.php</code> y comprueba que se visualiza de forma correcta.</li>
<li>Comprobemos la persistencia: elimina el Deployment, vuelve a crearlo y vuelve a acceder desde el navegador al fichero <code>info.php</code>. ¿Se sigue visualizando?</li>
</ol>
<hr>
<p>Creamos el fichero yaml que definirá el recurso PersistentVolumenClaim:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano pvc-webserver.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: pvc-webserver
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_43.png" alt="img_43.png"></p>
<p>Ahora creamos el recurso:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f pvc-webserver.yaml
</code></pre></div><p>Podemos ver que se ha creado ejecutando lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl get pc, pvc
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_44.png" alt="img_44.png"></p>
<p>Ahora crearemos el fichero que definirá el despliegue del servidor web:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano servidorweb-php.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: servidorweb
  labels:
    app: apache
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apache
  template:
    metadata:
      labels:
        app: apache
    spec:
      volumes:
        - name: volumen-servidorweb
          persistentVolumeClaim:
            claimName: pvc-webserver
      containers:
        - name: contenedor-apache-php
          image: php:7.4-apache
          ports:
            - name: http-server
              containerPort: 80
          volumeMounts:
            - mountPath: &#34;/var/www/html&#34;
              name: volumen-servidorweb
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_45.png" alt="img_45.png"></p>
<p>Y creamos el despliegue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f servidorweb-php.yaml
</code></pre></div><p>A continuación, creamos el fichero <code>.yaml</code> que definirá el servicio &lsquo;NodePort&rsquo; con el que accederemos al servidor web a través del navegador:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano servicioweb.yaml

apiVersion: v1
kind: Service
metadata:
  name: servicio-servidorweb
spec:
  type: NodePort
  ports:
  - name: service-http
    port: 80
    targetPort: http-server
  selector:
    app: apache
</code></pre></div><p>Y lo creamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f servidorweb-php.yaml
</code></pre></div><p>Ahora creamos el fichero <code>info.php</code> en la ruta que nos han indicado. Para ello, primero debemos averiguar cual es el identificador del pod:</p>
<p><img src="/images/ejercicios_kubernetes/img_46.png" alt="img_46.png"></p>
<p>Sabiendo esto, ejecutamos lo siguiente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl exec pod/servidorweb-745bc67f58-dmlbn -- bash -c &#34;echo &#39;&lt;?php phpinfo(); ?&gt;&#39; &gt; /var/www/html/info.php&#34;
</code></pre></div><p>Ahora accedemos a la ip de minikube, al puerto que nos indica el servicio (31757):</p>
<p><img src="/images/ejercicios_kubernetes/img_47.png" alt="img_47.png"></p>
<p>Como vemos, se muestra correctamente el php. Ahora veremos la persistencia. Para ello eliminamos el despliegue y lo volvemos a crear:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl delete deployment.apps/servidorweb

kubectl apply -f servidorweb-php.yaml
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_48.png" alt="img_48.png"></p>
<p>Y si volvemos a acceder:</p>
<p><img src="/images/ejercicios_kubernetes/img_49.png" alt="img_49.png"></p>
<p>Podemos seguir accediendo a la información tras haber destruido y creado el despliegue, por lo que confirmamos que el almacenamiento es persistente.</p>
<h3 id="haciendo-persistente-la-aplicación-guestbook">
  Haciendo persistente la aplicación GuestBook
  <a class="heading-link" href="#haciendo-persistente-la-aplicaci%c3%b3n-guestbook">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>En este ejercicio vamos a volver a desplegar nuestra aplicación GuestBook, que realizamos en <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo5/actividad3.md">Actividad 5.3: Despliegue de la aplicación GuestBook</a> y en la <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo6/actividad1.md">Actividad 6.1: Acceso de la aplicación GuestBook</a> para añadirle persistencia a la base de datos redis. Por lo tanto necesitaremos solicitar un volumen, que se asociará de forma dinámica.</p>
<p>Realiza los siguientes pasos:</p>
<ol>
<li>Crea un fichero yaml para definir un recurso PersistentVolumenClaim que se llame <code>pvc-redis</code> y para solicitar un volumen de 3Gb.</li>
<li>Crea el recurso y comprueba que se ha asociado un volumen de forma dinámica a la solicitud.</li>
<li>Modifica el fichero del despliegue de redis, modificando las <code>xxxxxxxxxxxx</code> por los valores correctos: el nombre del PersistentVolumenClaim y el directorio de montaje en el contenedor (como hemos visto anteriormente es <code>/data</code>).</li>
<li>Crea el despliegue de redis. El despliegue de la aplicación <code>guestbook</code> y la creación de los Services de acceso se hace con los ficheros que ya utilizamos anteriormente: <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo8/files/guestbook/guestbook-deployment.yaml">guestbook-deployment.yaml</a>, <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo8/files/guestbook/guestbook-srv.yaml">guestbook-srv.yaml</a> y <a href="https://github.com/iesgn/curso_kubernetes_cep/blob/main/modulo8/files/guestbook/redis-srv.yaml">redis-srv.yaml</a>.</li>
<li>Accede a la aplicación y escribe algunos mensajes.</li>
<li>Comprobemos la persistencia: elimina el despliegue de redis, vuelve a crearlo, vuelve a acceder desde el navegador y comprueba que los mensajes no se han perdido.</li>
</ol>
<hr>
<p>En primer lugar creamos el fichero <code>.yaml</code> para definir el recurso &ldquo;PersistentVolumenClaim&rdquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano pvc-redis.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: pvc-redis
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_50.png" alt="img_50.png"></p>
<p>Y lo creamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f pvc-redis.yaml
</code></pre></div><p>Vemos que se ha creado la solicitud y se ha asignado el volumen:</p>
<p><img src="/images/ejercicios_kubernetes/img_51.png" alt="img_51.png"></p>
<p>Creamos el fichero <code>.yaml</code> que define el despliegue de redis usando el volumen que hemos definido anteriormente:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano redis-despliegue.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  labels:
    app: redis
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      tier: backend
  template:
    metadata:
      labels:
        app: redis
        tier: backend
    spec:
      volumes:
        - name: volumen-redis
          persistentVolumeClaim:
            claimName: pvc-redis
      containers:
        - name: contenedor-redis
          image: redis
          command: [&#34;redis-server&#34;]
          args: [&#34;--appendonly&#34;, &#34;yes&#34;]
          ports:
            - name: redis-server
              containerPort: 6379
          volumeMounts:
            - mountPath: &#34;/data&#34;
              name: volumen-redis
</code></pre></div><p><img src="/images/ejercicios_kubernetes/img_52.png" alt="img_52.png"></p>
<p>Y el resto de recursos que necesitaremos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano guestbook-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: guestbook
  labels:
    app: guestbook
    tier: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: guestbook
      tier: frontend
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: contenedor-guestbook
        image: iesgn/guestbook
        ports:
          - name: http-server
            containerPort: 5000
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano guestbook-srv.yaml

apiVersion: v1
kind: Service
metadata:
  name: guestbook
  labels:
    app: guestbook
    tier: frontend
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: http-server
  selector:
    app: guestbook
    tier: frontend
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">nano redis-srv.yaml

apiVersion: v1
kind: Service
metadata:
  name: redis
  labels:
    app: redis
    tier: backend
spec:
  type: ClusterIP
  ports:
  - port: 6379
    targetPort: redis-server
  selector:
    app: redis
    tier: backend
</code></pre></div><p>Y los creamos todos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">kubectl apply -f .
</code></pre></div><p>Vemos que se han creado todos los recursos:</p>
<p><img src="/images/ejercicios_kubernetes/img_53.png" alt="img_53.png"></p>
<p>Ya podemos acceder a la aplicación de guestbook desde el navegador y crear algunos mensajes de prueba:</p>
<p><img src="/images/ejercicios_kubernetes/img_54.png" alt="img_54.png"></p>
<p>Ahora eliminamos el despliegue de redis y lo volvemos a crear, para comprobar si el almacenamiento es persistente:</p>
<p><img src="/images/ejercicios_kubernetes/img_55.png" alt="img_55.png"></p>
<p>Y entramos en la url para ver si los mensajes se han guardado:</p>
<p><img src="/images/ejercicios_kubernetes/img_56.png" alt="img_56.png"></p>
<p>Como vemos, se han guardado los mensajes, por lo que podemos dar por concluido el ejercicio.</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>El descenso hacia Debian profundo</p>
      
      
        ©
        
          2021 -
        
        2022
         Daniel Parrales 
      
      
         · 
        Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
      <script src="/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js" integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
